#include "tilemap.h"
#include <stdio.h>
#include <SDL2/SDL_image.h>

#define TILEMAP_MAP1_W 32
#define TILEMAP_MAP1_H 32
#define T_SIZE 16

static Tile tiles_types[] = {
    //   ID, SOLID, {SRC_X, SRC_Y, SRC_W, SRC_H}
    {0, false, TILE_EMPTY, {0, 0, T_SIZE, T_SIZE}},   // TILE_EMPTY
    {1, true, TILE_WALL, {32, 16, T_SIZE, T_SIZE}},   // TILE_WALL
    {2, false, TILE_FLOOR, {16, 64, T_SIZE, T_SIZE}}, // TILE_FLOOR
};
// TODO: when we are satisfied with the tilemap we can move it to a file
static int tilemap_map1[TILEMAP_MAP1_H][TILEMAP_MAP1_W] = {
    {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03},
    {0x03, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x0C, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
    {0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03},
};

int get_index(int x, int y, int width)
{
    return y * width + x;
}
bool remove_wall_candidate(int maze[], int width, int height, int x, int y)
{
    int count = 0;
    if (maze[get_index(x, y, width)] == 0)
    {
        return false;
    }
    if (y-1 == 0 || y+1 == height || x-1 == 0 || x+1 == width)
    {
        return false;
    }
    if (maze[get_index(x, y + 1, width)] == 0 && maze[get_index(x, y - 1, width)] == 0)
    {
        return true;
    }
    else if (maze[get_index(x - 1, y, width)] == 0 && maze[get_index(x + 1, y, width)] == 0)
    {
        return true;
    }
    return false;
}

/// @brief Generate a maze using the recursive backtracking algorithm
/// @param tilemap The tilemap to generate the maze
/// @param width
/// @param height
void generate_maze(TileMap *tilemap, int width, int height, int seed)
{
    int *maze = malloc(sizeof(int) * width * height);
    int *visited = malloc(sizeof(int) * width * height);
    for (int i = 0; i < width * height; i++)
    {
        // Initialize all cells as walls
        maze[i] = 1;
        // Initialize all cells as not visited

        // Initialize all cells as not visited
        visited[i] = 0;
    }

    srand(seed);
    int x = rand() % width;
    int y = rand() % height;
    recursive_backtrack(maze, visited, width, height, x, y);

    // Remove some walls to make the maze more interesting
    int count = 0;
    while (count < 20)
    {
        x = (rand() % (width));
        y = (rand() % (height));
        if (remove_wall_candidate(maze, width, height, x, y))
        {
            maze[get_index(x, y, width)] = 0;
            count++;
        }
    }
    for (int y = 0; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            int tile_id = maze[get_index(x,y,width)] ? TILE_WALL : TILE_FLOOR;
            Tile tile = tiles_types[tile_id];
            tilemap_set_tile(tilemap, x, y, &tile);
        }
    }
}
bool is_valid(int maze[], int width, int height, int x, int y)
{
    if (x < 0 || x >= width || y < 0 || y >= height)
    {
        return false;
    }
    return true;
}
void recursive_backtrack(int maze[], int visited[], int width, int height, int current_x, int current_y)
{
    visited[current_y * width + current_x] = 1;

    int directions[4][2] = {
        {0, -1},
        {0, 1},
        {-1, 0},
        {1, 0},
    };
    // Shuffle the directions array
    for (int i = 3; i > 0; i--)
    {
        int j = rand() % (i + 1);
        int temp[2] = {directions[i][0], directions[i][1]};
        directions[i][0] = directions[j][0];
        directions[i][1] = directions[j][1];
        directions[j][0] = temp[0];
        directions[j][1] = temp[1];
    }
    // Loop through the directions array
    for (int i = 0; i < 4; i++)
    {
        // Check if the next cell is within the bounds of the maze
        int new_x = current_x + directions[i][0] * 2;
        int new_y = current_y + directions[i][1] * 2;
        if (is_valid(maze, width, height, new_x, new_y) && !visited[new_y * width + new_x])
        {
            
            // neighbor is not visited
            maze[new_y * width + new_x] = 0;
            maze[(current_y + directions[i][1]) * width + (current_x + directions[i][0])] = 0;
            // Recursively call the function with the new cell
            recursive_backtrack(maze, visited, width, height, new_x, new_y);
        }
    }
}
void tilemap_load(TileMap *tilemap, int map_id)
{
    if (map_id == 1)
    {

        for (int y = 0; y < TILEMAP_MAP1_H; y++)
        {
            for (int x = 0; x < TILEMAP_MAP1_W; x++)
            {
                Tile tile = tiles_types[tilemap_map1[y][x]];

                tilemap_set_tile(tilemap, x, y, &tile);
            }
        }
    }
    else if (map_id == 2)
    {
        generate_maze(tilemap, TILEMAP_MAP1_W, TILEMAP_MAP1_H, 0);
    }
    else
    {
        printf("Error: Map not found\n");
    }
}

void tilemap_load_file(TileMap *tilemap, const char *path)
{
    printf("Error: Not implemented\n");
    return;
}
void tilemap_save_file(TileMap *tilemap, const char *path)
{
    printf("Error: Not implemented\n");
    return;
}

void tilemap_init(TileMap *tilemap, SDL_Renderer *renderer, int width, int height, int tile_size)
{
    tilemap->width = width;
    tilemap->height = height;
    tilemap->tiles = malloc(sizeof(Tile) * width * height);
    tilemap->tile_size = tile_size;
    tilemap->pRenderer = renderer;
    tilemap->x = 0;
    tilemap->y = 0;
    SDL_Surface *surface = IMG_Load("resources/tiles/0x72_dungeonTileset2_v1.7.png"); // Temporary tilemap image
    if (!surface)
    {
        printf("Error: %s\n", SDL_GetError());
        SDL_DestroyRenderer(renderer);
        SDL_Quit();
        return;
    }
    tilemap->pTexture = SDL_CreateTextureFromSurface(renderer, surface);

    SDL_FreeSurface(surface);
}

void tilemap_set_tile(TileMap *tilemap, int x, int y, Tile *tile)
{
    tilemap->tiles[y * tilemap->width + x] = *tile;
}

void tilemap_draw(TileMap *tilemap)
{
    SDL_Rect possition;
    possition.x = 0;
    possition.y = 0;
    possition.w = tilemap->tile_size;
    possition.h = tilemap->tile_size;
    for (int y = 0; y < tilemap->height; y++)
    {
        for (int x = 0; x < tilemap->width; x++)
        {
            Tile *tile = get_tile(tilemap, x, y);
            if (tile != NULL)
            {
                possition.x = x * tilemap->tile_size - tilemap->x;
                possition.y = y * tilemap->tile_size - tilemap->y;
                SDL_RenderCopyEx(tilemap->pRenderer, tilemap->pTexture, &tile->src_rect, &possition, 0, NULL, SDL_FLIP_NONE);
            }
        }
    }
}

Tile *get_tile(TileMap *tilemap, int x, int y)
{
    if (x < 0 || x >= tilemap->width || y < 0 || y >= tilemap->height)
    {
        return NULL;
    }
    return &tilemap->tiles[y * tilemap->width + x];
}

Tile *get_world_tile(TileMap *tilemap, int x, int y)
{
    x /= tilemap->tile_size;
    y /= tilemap->tile_size;
    if (x < 0 || x >= tilemap->width || y < 0 || y >= tilemap->height)
    {
        return NULL;
    }
    return &tilemap->tiles[y * tilemap->width + x];
}

void tilemap_free(TileMap *tilemap)
{
    free(tilemap->tiles);
    tilemap->tiles = NULL;
    SDL_DestroyTexture(tilemap->pTexture);
    tilemap->pTexture = NULL;
    tilemap->pRenderer = NULL;
}
